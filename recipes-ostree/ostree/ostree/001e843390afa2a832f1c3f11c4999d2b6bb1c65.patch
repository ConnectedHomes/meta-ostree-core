From 001e843390afa2a832f1c3f11c4999d2b6bb1c65 Mon Sep 17 00:00:00 2001
From: Colin Walters <walters@verbum.org>
Date: Thu, 22 Mar 2018 10:14:22 -0400
Subject: [PATCH] switchroot: Ensure /run/ostree-booted is created even without
 initramfs

See https://mail.gnome.org/archives/ostree-list/2018-March/msg00012.html

If ostree-prepare-root is run as pid 1 (i.e we're not using an initramfs), then
anything we write outside the target sysroot (such as `/run/ostree-booted`) will
be lost.

Since `ostree-remount.service` runs fairly early in boot, and is triggered via
`ConditionKernelCommandLine=ostree`, we can just touch the file there in
addition.
---
 src/switchroot/ostree-mount-util.h   | 15 +++++++++++++++
 src/switchroot/ostree-prepare-root.c | 25 +++++++------------------
 src/switchroot/ostree-remount.c      | 10 ++++++++++
 3 files changed, 32 insertions(+), 18 deletions(-)

diff --git a/src/switchroot/ostree-mount-util.h b/src/switchroot/ostree-mount-util.h
index 7cf7e09e1..08e10f976 100644
--- a/src/switchroot/ostree-mount-util.h
+++ b/src/switchroot/ostree-mount-util.h
@@ -104,4 +104,19 @@ read_proc_cmdline_ostree (void)
   return ret;
 }
 
+/* This is an API for other projects to determine whether or not the
+ * currently running system is ostree-controlled.
+ */
+static inline void
+touch_run_ostree (void)
+{
+  int fd = open ("/run/ostree-booted", O_CREAT | O_WRONLY | O_NOCTTY | O_CLOEXEC, 0640);
+  /* We ignore failures here in case /run isn't mounted...not much we
+   * can do about that, but we don't want to fail.
+   */
+  if (fd == -1)
+    return;
+  (void) close (fd);
+}
+
 #endif /* __OSTREE_MOUNT_UTIL_H_ */
diff --git a/src/switchroot/ostree-prepare-root.c b/src/switchroot/ostree-prepare-root.c
index 0b04189eb..a5c3c785e 100644
--- a/src/switchroot/ostree-prepare-root.c
+++ b/src/switchroot/ostree-prepare-root.c
@@ -48,23 +48,6 @@
 
 #include "ostree-mount-util.h"
 
-/* This is an API for other projects to determine whether or not the
- * currently running system is ostree-controlled.
- */
-static void
-touch_run_ostree (void)
-{
-  int fd;
-
-  fd = open ("/run/ostree-booted", O_CREAT | O_WRONLY | O_NOCTTY | O_CLOEXEC, 0640);
-  /* We ignore failures here in case /run isn't mounted...not much we
-   * can do about that, but we don't want to fail.
-   */
-  if (fd == -1)
-    return;
-  (void) close (fd);
-}
-
 static char*
 resolve_deploy_path (const char * root_mountpoint)
 {
@@ -205,7 +188,13 @@ main(int argc, char *argv[])
         err (EXIT_FAILURE, "failed to bind mount (class:readonly) /usr");
     }
 
-  touch_run_ostree ();
+
+  /* We only stamp /run now if we're running in an initramfs, i.e. we're
+   * not pid 1.  Otherwise it's handled later via ostree-remount.service.
+   * https://mail.gnome.org/archives/ostree-list/2018-March/msg00012.html
+   */
+  if (getpid () != 1)
+    touch_run_ostree ();
 
   if (strcmp(root_mountpoint, "/") == 0)
     {
diff --git a/src/switchroot/ostree-remount.c b/src/switchroot/ostree-remount.c
index 3644a0635..c3e39c0be 100644
--- a/src/switchroot/ostree-remount.c
+++ b/src/switchroot/ostree-remount.c
@@ -46,6 +46,16 @@ main(int argc, char *argv[])
   struct stat stbuf;
   int i;
 
+  /* See comments in ostree-prepare-root.c for this.
+   *
+   * This service is triggered via
+   * ConditionKernelCommandLine=ostree
+   * but it's a lot easier for various bits of userspace to check for
+   * a file versus parsing the kernel cmdline.  So let's ensure
+   * the stamp file is created here too.
+   */
+  touch_run_ostree ();
+
   /* The /sysroot mount needs to be private to avoid having a mount for e.g. /var/cache
    * also propagate to /sysroot/ostree/deploy/$stateroot/var/cache
    *
